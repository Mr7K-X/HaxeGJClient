package gamejolt;

import gamejolt.formats.*;
import gamejolt.types.*;
import openfl.events.*;

using Lambda;
using StringTools;

/**
 * The general GameJolt class you can be able to make calls to its API from.
 * @see For more info about how to formulate calls correctly: https://github.com/GamerPablito/HaxeGJClient
 */
class GJRequest
{
	/**
	 * The actual URL created by the parsing of the current `call`.
	 */
	public var url(get, never):String;

	/**
	 * The last response generated by `send()` spawns here.
	 */
	public var lastResponse(default, null):Response = {success: false, message: "No response has been received yet"};

	/**
	 * The current instruction `this` is willing to execute. Cannot be modified while `executing == true`.
	 */
	public var call(default, set):RequestType;

	/**
	 * Whether if the current `url` is being executed by `send()` or not.
	 */
	public var executing(default, null):Bool = false;

	/**
	 * An event dispatcher you can set up to be called by `send()` when the current execution ends successfully.
	 *
	 * @param `Response` - This is how GameJolt API responses are formatted like
	 * @return And these will working in client (if operation completed).
	 */
	public var onComplete:Response->Void;

	/**
	 * An event dispatcher you can set up to be called by `send()` while the current execution is progressing.
	 *
	 * @param Float - How much bytes is loaded.
	 * @param Float - How much bytes is total.
	 * @return And these will working when client `send()` something.
	 */
	public var onProgress:Float->Float->Void;

	/**
	 * An event dispatcher you can set up to be called by `send()` when the current execution ends with an error of any kind.
	 *
	 * @param String - Error Message.
	 * @return When client throw a error, this will working.
	 */
	public var onError:String->Void;

	public function new(Call:RequestType)
		call = Call;

	function get_url():String
		return signature('https://api.gamejolt.com/api/game/v1_2${parseType(call)}');

	function set_call(value:RequestType):RequestType
	{
		if (executing)
			return call;
		return call = value;
	}

	/**
	 * Sends the current `call` to the GameJolt API to return a `Response` from it, if `executing == false`.
	 * @return A `Future` instance that returns a `Response` from the GameJolt API while saving it in `lastResponse`.
	 */
	public function send()
	{
		if (executing)
			return;
		executing = true;

		var loader = new openfl.net.URLLoader();
		loader.addEventListener(Event.COMPLETE, (complete) ->
		{
			lastResponse = formatImages(cast haxe.Json.parse(loader.data).response);
			if (lastResponse.message != null)
				if (onError != null)
					onError('Response Error: ${lastResponse.message}');
				else if (onComplete != null)
					onComplete(lastResponse);

			executing = false;
		});
		loader.addEventListener(ProgressEvent.PROGRESS, progress ->
		{
			if (onProgress != null)
				onProgress(progress.bytesLoaded, progress.bytesTotal);
		});
		loader.addEventListener(IOErrorEvent.IO_ERROR, (ioError) ->
		{
			lastResponse = {success: false, message: 'IO Error: ${ioError.text}'}
			if (onError != null)
				onError(lastResponse.message);
			executing = false;
		});
		loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityError ->
		{
			lastResponse = {success: false, message: 'Security Error: ${securityError.text}'}
			if (onError != null)
				onError(lastResponse.message);
			executing = false;
		});
		loader.load(new openfl.net.URLRequest(url));
	}

	/**
	 * Makes retrieved images to have a better resolution.
	 * @param oldRes The `Response` to be modified.
	 * @return A new `Response` with every Image URL modified for a better resolution when requested.
	 */
	function formatImages(res:Response):Response
	{
		if (res.users != null)
			res.users.iter(u -> u.avatar_url = '${u.avatar_url.substring(0, 32)}1000${u.avatar_url.substr(34)}'.replace(".jpg", ".png")
				.replace(".webp", ".png"));

		if (res.trophies != null)
			res.trophies.iter((t) ->
			{
				var newUrl:String = "";
				if (t.image_url.startsWith('https://m.'))
					newUrl = '${t.image_url.substring(0, 37)}1000${t.image_url.substr(40)}'.replace(".jpg", ".png").replace(".webp", ".png");
				else
				{
					newUrl = "https://s.gjcdn.net/assets/";
					newUrl += switch (t.image_url.substring(24).replace(".jpg", "").replace(".webp", ""))
					{
						case "trophy-bronze-1": "9c2c91d0";
						case "trophy-silver-1": "b46e352e";
						case "trophy-gold-1": "363ce2dc";
						case "trophy-platinum-1": "92e5330d";
						default: "";
					};
					newUrl += ".png";
				}
				t.image_url = newUrl;
			});

		if (res.responses != null)
			res.responses.iter(res2 -> res2 = formatImages(res2));

		return res;
	}

	/**
	 * Converts a `RequestType` instance into a piece of stringified URL.
	 * @param request The `RequestType` that will be converted to String.
	 * @param signed Whether to sign this conversion or not.
	 * @return The new URL piece.
	 */
	function parseType(request:RequestType, signed:Bool = false):String
	{
		var command:String = "";
		var action:String = "";
		var params:Array<{name:String, value:String}> = [];

		switch (request)
		{
			// DATA //

			case DataFetch(key, fromUser):
				command = "data-store";
				params.push({name: "key", value: key.urlEncode()});
				if (fromUser)
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
			case DataGetKeys(fromUser, pattern):
				command = "data-store";
				action = "get-keys";
				if (pattern != null && pattern != "")
					params.push({name: "pattern", value: pattern.urlEncode()});
				if (fromUser)
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
			case DataRemove(key, fromUser):
				command = "data-store";
				action = "remove";
				params.push({name: "key", value: key.urlEncode()});
				if (fromUser)
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
			case DataSet(key, data, toUser):
				command = "data-store";
				action = "set";
				params.push({name: "key", value: key.urlEncode()});
				params.push({name: "data", value: data.urlEncode()});
				if (toUser)
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
			case DataUpdate(key, operation, toUser):
				command = "data-store";
				action = "update";
				params.push({name: "key", value: key.urlEncode()});
				if (toUser)
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
				switch (operation)
				{
					case Add(n):
						params.push({name: 'operation', value: 'add'});
						params.push({name: 'value', value: '$n'});
					case Substract(n):
						params.push({name: 'operation', value: 'substract'});
						params.push({name: 'value', value: '$n'});
					case Multiply(n):
						params.push({name: 'operation', value: 'multiply'});
						params.push({name: 'value', value: '$n'});
					case Divide(n):
						params.push({name: 'operation', value: 'divide'});
						params.push({name: 'value', value: '$n'});
					case Append(t):
						params.push({name: 'operation', value: 'append'});
						params.push({name: 'value', value: t.urlEncode()});
					case Prepend(t):
						params.push({name: 'operation', value: 'prepend'});
						params.push({name: 'value', value: t.urlEncode()});
				}

			// USER //

			case UserAuth:
				command = "users";
				action = "auth";
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case UserFetch(userOrIDList):
				command = "users";
				if (userOrIDList != [])
					params.push({
						name: userOrIDList.exists(userOrID -> Std.parseInt(userOrID) == null) ? "username" : "user_id",
						value: userOrIDList.join(",").urlEncode()
					});

			// SESSION //

			case SessionOpen:
				command = "sessions";
				action = "open";
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case SessionPing(active):
				command = "sessions";
				action = "ping";
				params.push({name: "status", value: active ? "active" : "idle"});
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case SessionCheck:
				command = "sessions";
				action = "check";
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case SessionClose:
				command = "sessions";
				action = "close";
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});

			// SCORES //

			case ScoresAdd(score, sort, extra_data, table_id):
				command = "scores";
				action = "add";
				params.push({name: "score", value: score});
				params.push({name: "sort", value: '$sort'});
				if (extra_data != null && extra_data != "")
					params.push({name: "extra_data", value: extra_data.urlEncode()});
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
				if (GJApi.userToken != "")
				{
					params.push({name: "username", value: GJApi.userName});
					params.push({name: "user_token", value: GJApi.userToken});
				}
				else
					params.push({name: "guest", value: GJApi.userName});
			case ScoresGetRank(sort, table_id):
				command = "scores";
				action = "get-rank";
				params.push({name: "sort", value: '$sort'});
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
			case ScoresFetch(fromUser, table_id, limit, betterThan):
				command = "scores";
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
				if (limit != null)
					params.push({name: "limit", value: '$limit'});
				if (betterThan != null)
					params.push({name: betterThan < 0 ? "worse_than" : "better_than", value: '${Math.abs(betterThan)}'});
				if (fromUser)
				{
					if (GJApi.userToken != "")
					{
						params.push({name: "username", value: GJApi.userName});
						params.push({name: "user_token", value: GJApi.userToken});
					}
					else
						params.push({name: "guest", value: GJApi.userName});
				}
			case ScoresTables:
				command = "scores";
				action = "tables";

			// TROPHIES //

			case TrophiesFetch(achieved, trophy_id):
				command = "trophies";
				if (achieved != null)
					params.push({name: "achieved", value: '$achieved'});
				if (trophy_id != null)
					params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case TrophiesAdd(trophy_id):
				command = "trophies";
				action = "add-achieved";
				params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case TrophiesRemove(trophy_id):
				command = "trophies";
				action = "remove-achieved";
				params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});

			// OTHERS //

			case Batch(parallel, breakOnError, requests):
				command = "batch";
				params.push({name: "parallel", value: '$parallel'});
				params.push({name: "break_on_error", value: '$breakOnError'});
				for (req in requests)
					params.push({name: "requests[]", value: parseType(req, true)});
			case Friends:
				command = "friends";
				params.push({name: "username", value: GJApi.userName});
				params.push({name: "user_token", value: GJApi.userToken});
			case Time:
				command = "time";
		}

		var urlSection:String = '/$command${action != "" ? '/$action' : ""}?game_id=${GJApi.gameID}${[for (p in params) '&${p.name}=${p.value}'].join("")}';
		if (signed)
			urlSection = signature(urlSection).urlEncode();

		return urlSection;
	}

	/**
	 * Signs a piece of URL according to `usingMd5` parameter of the `GameJolt` class.
	 * @param daUrl The old URL piece.
	 * @return The new URL piece.
	 */
	function signature(daUrl:String):String
	{
		var urlToEncode:String = daUrl + GJApi.gameKey;
		return '$daUrl&signature=${GJApi.usingMd5 ? haxe.crypto.Md5.encode(urlToEncode) : haxe.crypto.Sha1.encode(urlToEncode)}';
	}
}
